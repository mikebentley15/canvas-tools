#!/usr/bin/env python
'''
Uploads scores for a particular assignment into Canvas where the assignment has
been split up into individual problems using an assignment rubric.

This script takes a CSV file to upload these scores automatically.
'''

import argparse
import csv
import re
import sys
import warnings

import requests

def json_get_list(url, params):
    '''
    Performs a GET and recurses through "pages"
    @return json_value
    '''
    req = requests.get(url, params=params)
    json_val = req.json()
    header_split = req.headers['Link'].split(',')
    pcopy = dict(params)
    for hval in header_split:
        match = re.match('<.*\\?page=([0-9]+).*>; rel="next"', hval)
        if match is not None:
            pcopy['page'] = match.group(1)
            json_val.extend(json_get_list(url, params=pcopy))
    return json_val

def get_all_courses(apibase, token):
    '''
    Return a list of classes for the user whost token is given.

    @param apibase: the website base for the api interface
      (ex. 'https://utah.instructure.edu/api/v1')
    @param token: token generated by Canvas to access the login stuff

    @return list of json objects, one for each class taken.
    '''
    return json_get_list(apibase + '/courses',
                         params={
                             'access_token' : token,
                             'per_page' : '100',
                             'page' : '1',
                             })

def get_all_assignments(apibase, token, course_id):
    '''
    Return a list of assignments for the given course.

    @param apibase: the website base for the api interface
      (ex. 'https://utah.instructure.edu/api/v1')
    @param token: token generated by Canvas to access the login stuff
    @param course_id: id of the course

    @return list of json objects, one for each assignment in the course.
    '''
    return json_get_list(apibase +
                         '/courses/' + str(course_id) +
                         '/assignments',
                         params={
                             'access_token' : token,
                             'per_page' : '100',
                             'page' : '1',
                             })

def get_all_students(apibase, token, course_id, assignment_id):
    '''
    Return a list of students for the given course.

    @param apibase: the website base for the api interface
      (ex. 'https://utah.instructure.edu/api/v1')
    @param token: token generated by Canvas to access the login stuff
    @param course_id: id of the course
    @param assignment_id: id of the assignment being graded

    @return list of json objects, one for each student in the course.
    '''
    return json_get_list(apibase +
                         '/courses/' + str(course_id) +
                         '/assignments/' + str(assignment_id) +
                         '/gradeable_students',
                         params={
                             'access_token' : token,
                             'per_page' : '100',
                             'page' : '1',
                             })

def push_graded_rubric(apibase, token, course_id, assignment_id, student_id,
                       graded_rubric):
    '''
    Write out the graded rubric for the given student's assignment within the
    given course.

    @param apibase: the website base for the api interface
      (ex. 'https://utah.instructure.edu/api/v1')
    @param token: token generated by Canvas to access the login stuff
    @param course_id: id of the course
    @param assignment_id: id of the assignment being graded
    @param student_id: id of the student
    @param graded_rubric: grading on each problem

    @return None
    '''
    requests.put(apibase +
                 '/courses/' + str(course_id) +
                 '/assignments/' + str(assignment_id) +
                 '/submissions/' + str(student_id),
                 params={
                     'access_token' : token,
                     'include[]' : 'rubric_assessment',
                     },
                 data=graded_rubric
                )

def main(arguments):
    'Main logic here'
    # Parse arguments
    parser = argparse.ArgumentParser(
        description='''
            Uploads scores for a particular assignment into Canvas.  The
            assignment must be split up into individual problems using an
            assignment rubric.
            ''')
    #parser.add_argument('--args-file', help='File containing command-line arguments')
    parser.add_argument('--list-courses', action='store_true',
                        help='List all courses')
    parser.add_argument('--list-assignments', action='store_true',
                        help='List all assignments.  Needs the course to be '
                             'specified')
    parser.add_argument('--list-assignment-rubric', action='store_true',
                        help='Show rubric for the given assignment.')
    parser.add_argument('-w', '--website',
                        default='https://utah.instructure.com',
                        help='Canvas website, e.g. '
                             'https://utah.instructure.com')
    parser.add_argument('-t', '--token',
                        help='Token generated from Canvas.')
    parser.add_argument('-c', '--course', help='Course name')
    parser.add_argument('--course-id', type=int, default=0, help='Course ID')
    parser.add_argument('-a', '--assignment', help='Name of the assignment for upload')
    parser.add_argument('--assignment-id', type=int, default=0, help='Assignment ID')
    parser.add_argument('-n', '--dry-run', action='store_true', help='Pretend to push grades')
    parser.add_argument('csv', nargs='?', default='',
                        help='''
                            A csv file for uploading of a single assignment.
                            The csv file must have at least a column named
                            'student_ids' which are the IDs of the students
                            that Canvas has given them.  You can get these by
                            doing a download of the gradebook.  This prevents
                            the need to depend on things such as the name of
                            the student.  It is possible that two students
                            share the same name (albeit not common).  The other
                            column headers are to be the exact names of the
                            sections of the assignment's rubric.  The values in
                            those columns are the scores to assign to each one.
                            '''
                       )

    args = parser.parse_args(arguments)
    api = args.website + '/api/v1'

    # Get the courses.  Return the list if requested
    courses = get_all_courses(api, args.token)
    if args.list_courses:
        max_id_len = max(len(str(x['id'])) for x in courses)
        print('Courses:')
        print('  ID{0}NAME'.format(' ' * (max_id_len + 4 - 2)))
        for course in courses:
            print('  {0}{1}{2}'.format(
                course['id'],
                ' ' * (max_id_len + 4 - len(str(course['id']))),
                course['name']))
        return 0

    # Find the matching course object
    matching_courses = [x for x in courses if x['name'] == args.course
                                           or x['id'] == args.course_id]
    if len(matching_courses) == 0:
        print('provided course is not found', file=sys.stderr)
        return 1
    assert len(matching_courses) == 1
    course = matching_courses[0]

    # Get all assignments.  Return the list if requested
    assignments = get_all_assignments(api, args.token, course['id'])
    if args.list_assignments:
        max_id_len = max(len(str(x['id'])) for x in assignments)
        print('Assignments:')
        print('  ID{0}NAME'.format(' ' * (max_id_len + 4 - 2)))
        for assignment in assignments:
            print('  {0}{1}{2}'.format(
                assignment['id'],
                ' ' * (max_id_len + 4 - len(str(assignment['id']))),
                assignment['name']))
        return 0

    # Find the matching assignment object
    matching_assignments = [x for x in assignments if x['name'] == args.assignment
                                                   or x['id'] == args.assignment_id]
    if len(matching_assignments) == 0:
        print('provided assignment name is not found', file=sys.stderr)
        return 1
    assert len(matching_assignments) == 1
    assignment = matching_assignments[0]

    # List the assignment rubric if requested
    if args.list_assignment_rubric:
        rubric = assignment['rubric']
        max_name_len = max(4, max(len(str(x['description'])) for x in rubric))
        print('Assignment Rubric:')
        print('  NAME{0}POINTS'.format(' ' * (max_name_len + 4 - 4)))
        for element in rubric:
            print('  {0}{1}{2}'.format(
                element['description'],
                ' ' * (max_name_len + 4 - len(str(element['description']))),
                element['points']))
        return 0


    # Get all students.
    students = get_all_students(api, args.token, course['id'], assignment['id'])
    student_map = {str(x['id']) : x['display_name'] for x in students}

    # Parse the CSV file
    if args.csv == '':
        print('CSV file must be provided', file=sys.stderr)
        return 1
    with open(args.csv, 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        csv_rows = [x for x in reader]
    assert len(csv_rows) > 0, 'csv file is empty'
    assert 'student_id' in csv_rows[0], \
            'csv file does not have "student_id" column'

    student_ids = set(student_map.keys())
    csv_student_ids = set([x['student_id'] for x in csv_rows])
    if len(csv_student_ids) != len(csv_rows):
        csv_ids = sorted([x['student_id'] for x in csv_rows])
        duplicate_ids = set()
        for i in range(len(csv_ids)-1):
            if csv_ids[i] == csv_ids[i+1]:
                duplicate_ids.add(csv_ids[i])
        warnings.warn('The following student id\'s are specified more than once: '
                      + ','.join(sorted(duplicate_ids)))
    not_in_csv = student_ids - csv_student_ids
    extra_in_csv = csv_student_ids - student_ids
    if len(not_in_csv) > 0:
        warnings.warn('These students are not in the csv:\n  ' +
                      '\n  '.join([student_map[x] for x in not_in_csv]))
    assert len(extra_in_csv) == 0, \
            'Students in csv that are not gradeable:\n' + \
            '\n  '.join(sorted(extra_in_csv, key=lambda x: int(x)))

    # Map the rubric name -> id for use in creating the graded rubric
    rubric_id_map = {x['description'] : x['id'] for x in assignment['rubric']}
    assert all(x in csv_rows[0] for x in rubric_id_map), \
            'some problems are not in the csv file'

    for row in csv_rows:
        graded_rubric = {}
        for name in rubric_id_map:
            grade = row[name]
            rubric_key = 'rubric_assessment[{0}][points]'.format(rubric_id_map[name])
            graded_rubric[rubric_key] = grade
            #rubric_key = 'rubric_assessment[{0}][comment]'.format(rubric_id_map[name])
            #graded_rubric[rubric_key] = 'my comment'
        if not args.dry_run:
            push_graded_rubric(api, args.token, course['id'], assignment['id'],
                               row['student_id'], graded_rubric)
        print('Pushed grade total',
              sum(float(x) for x in graded_rubric.values() if x != ''),
              'for', student_map[row['student_id']])

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
